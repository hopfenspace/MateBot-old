const MAX_COMMUNISM = 50;
const STATE_FILE = "state.json";
const LOG_FILE = "transactions.log";
const BOT_TOKEN = "<bot token here>";



import f*, str*, puts, memcpy, isnan, isinf;
const SEEK_SET = 0;
const SEEK_END = 2;

import List from "libs/list.ptrs";
import Map from "libs/map.ptrs";
import json_encode, json_decode from "libs/json.ptrs";
import Telegram, MessageUpdate, InlineKeyboard, CallbackQuery from "libs/telegram.ptrs";

var accounts;
var communism = false;
var logFd = fopen(LOG_FILE, "a+");

scoped
{
	var fd = fopen(STATE_FILE, "r");
	if(!fd)
	{
		accounts = new Map();
	}
	else
	{
		fseek(fd, 0, SEEK_END);
		var size = ftell(fd);
		fseek(fd, 0, SEEK_SET);

		var content = new_stack array{size + 1};
		fread(content, size, 1, fd);
		fclose(fd);
		content[size] = 0;

		accounts = json_decode(content);
	}
}

function arraydup(str)
{
	var dup = new array{sizeof str};
	memcpy(dup, str, sizeof str);
	return dup;
}
function saveState()
{
	var str = json_encode(accounts);
	var fd = fopen(STATE_FILE, "w+");

	fwrite(str, 1, (sizeof str) - 1, fd);
	fputc('\n', fd);
	fclose(fd);

	delete str;
}
function createTransaction(user, diff, reason)
{
	fputs("${user.id} (${user.name}) : $diff€: $reason\n", logFd);
	fflush(logFd);
	user.balance += diff;
}
function createUser(id, name)
{
	if(!(id in accounts))
	{
		accounts[id] = map {
			id: id,
			name: arraydup(name),
			balance: 0
		};

		saveState();
	}
}
function checkCommand(text, cmd, argptr)
{
	var cmdlen = strlen(cmd);
	if(strncmp(text, cmd, cmdlen) != 0
		|| (text[cmdlen] != '@' && text[cmdlen] != ' ' && text[cmdlen] != 0))
		return false;

	if(argptr)
	{
		if(text[cmdlen] == '@')
		{
			var arg = strstr!native(text + cmdlen, " ");
			if(arg != NULL)
				*argptr = (arg + 1)[0 .. sizeof text - (arg - text) - 1];
			else
				*argptr = NULL;
		}
		else if(text[cmdlen] == 0)
		{
			*argptr = NULL;
		}
		else
		{
			*argptr = text + cmdlen;
		}
	}

	return true;
}
function deleteCommunism()
{
	delete communism.communists;
	delete communism.keyboard;
	delete communism.comment;
	delete communism.text;
	delete communism;
	communism = false;
}

var bot = new Telegram(BOT_TOKEN);
while(true) try
{
	var msg = bot.getUpdate();

	if(msg instanceof CallbackQuery)
	{
		createUser(msg.senderId, msg.sender);

		if(!communism)
		{
		}
		else if(strcmp(msg.action, "JOIN / LEAVE") == 0)
		{
			var index = communism.communists.indexOf(msg.senderId);
			if(index == -1)
			{
				communism.communists.add(msg.senderId);
				msg.answer("You are now a communist");
			}
			else
			{
				communism.communists.splice(index, 1);
				msg.answer("You are no longer a communist");
			}

			var text = "";
			var ids = communism.communists;

			if(ids.length == 0)
			{
				bot.editMessage(msg.message.chat, msg.message.id,
					"Everyone left, the communism died");
				deleteCommunism();
			}
			else
			{
				for(var i = 0; i < ids.length; i++)
				{
					text = "$text, ${accounts[ids[i]].name}";
				}

				text += 2;

				text = "${communism.text}\nCommunists: $text";
				bot.editMessage(msg.message.chat, msg.message.id, text, _, communism.keyboard);
			}
		}
		else if(msg.senderId != communism.creator)
		{
			msg.answer("You are not allowed to do that");
		}
		else if(strcmp(msg.action, "OK") == 0)
		{
			var count = communism.communists.length;
			var split = cast<float>communism.amount / cast<float>count;

			var ids = communism.communists;
			var text = "";
			for(var i = 0; i < ids.length; i++)
			{
				var user = accounts[ids[i]];
				createTransaction(user, -split, "communism");
				text = "$text, ${user.name}";
			}

			var creator = accounts[communism.creator];
			createTransaction(creator, communism.amount, "communism");
			text = "$text payed $split€"
				"\n${creator.name} received ${communism.amount}€"
				"\nDescription: ${communism.comment}";

			saveState();

			bot.editMessage(msg.message.chat, msg.message.id, text + 2);
			deleteCommunism();
		}
		else if(strcmp(msg.action, "CANCEL") == 0)
		{
			bot.editMessage(msg.message.chat, msg.message.id, "Communism canceled");
			deleteCommunism();
		}
	}
	else if(msg instanceof MessageUpdate)
	{
		createUser(msg.senderId, msg.sender);

		var arg;
		if(checkCommand(msg.text, "/drink"))
		{
			createTransaction(accounts[msg.senderId], -1, "drink");

			msg.reply("OK, enjoy your drink!");
			saveState();
		}
		else if(checkCommand(msg.text, "/balance"))
		{
			msg.reply("Your balance is: ${accounts[msg.senderId].balance}€");
		}
		else if(checkCommand(msg.text, "/blame"))
		{
			var min = false;
			foreach(_, user in accounts)
			{
				if(!min || min.balance >= user.balance)
				{
					min = user;
				}
			}

			msg.reply("It's [${min.name}](tg://user?id=${min.id})s turn to restock the Mate", "markdown");
		}
		else if(checkCommand(msg.text, "/communism", &arg))
		{
			if(communism)
			{
				msg.reply("There is already a communism in progress");
			}
			else if(!arg)
			{
				msg.reply("Usage: /communism <amount>\nSplit a bill onto multiple people");
			}
			else
			{
				var comment = NULL;
				var amount = strtod!double(arg, &comment);
				if(amount < 0 || amount > MAX_COMMUNISM
					|| isnan(amount) || isinf(amount))
				{
					msg.reply("Invalid amount: $amount");
				}
				else
				{
					var communists = new List();
					communists.add(msg.senderId);

					var keyboard = new InlineKeyboard(2);
					keyboard.addButton(0, "JOIN / LEAVE");
					keyboard.addButton(1, "OK");
					keyboard.addButton(1, "CANCEL");

					if(!comment || *comment == 0)
						comment = "none";
					else
						comment = comment[0 .. sizeof arg - (comment - arg)];

					var text = "Everyone who wants to join or leave ${msg.sender}' "
							"communism can now click JOIN / LEAVE"
						"\nAmount: ${amount}€"
						"\nDescription: $comment";

					msg.reply("$text\nCommunists: ${msg.sender}", undefined, keyboard);

					communism = map {
						creator: msg.senderId,
						amount: amount,
						text: arraydup(text),
						comment: arraydup(comment),
						keyboard: keyboard,
						communists: communists
					};
				}
			}
		}
		else if(checkCommand(msg.text, "/pay"))
		{
			msg.reply("Soon™");
		}
	}

	delete msg;
}
catch(err, trace)
{
	puts("$err\n$trace");
}