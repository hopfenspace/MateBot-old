const STATE_FILE = "state.json";
const BOT_TOKEN = "<bot token here>";



import f*, str*;
const SEEK_SET = 0;
const SEEK_END = 2;

import Map from "libs/map.ptrs";
import json_encode, json_decode from "libs/json.ptrs";
import Telegram, MessageUpdate from "libs/telegram.ptrs";

var accounts;

scoped
{
	var fd = fopen(STATE_FILE, "r");
	if(!fd)
	{
		accounts = new Map();
	}
	else
	{
		fseek(fd, 0, SEEK_END);
		var size = ftell(fd);
		fseek(fd, 0, SEEK_SET);

		var content = new_stack array{size + 1};
		fread(content, size, 1, fd);
		fclose(fd);
		content[size] = 0;

		accounts = json_decode(content);
	}
}

function saveState()
{
	var str = json_encode(accounts);
	var fd = fopen(STATE_FILE, "w+");

	fwrite(str, 1, (sizeof str) - 1, fd);
	fputc('\n', fd);
	fclose(fd);

	delete str;
}
function checkCommand(text, cmd, argptr)
{
	var cmdlen = strlen(cmd);
	if(strncmp(text, cmd, cmdlen) != 0
		|| (text[cmdlen] != '@' && text[cmdlen] != ' ' && text[cmdlen] != 0))
		return false;

	if(argptr)
	{
		if(text[cmdlen] == '@')
		{
			var arg = strstr!native(text + cmdlen, " ");
			if(arg != NULL)
				*argptr = (arg + 1)[0 .. sizeof text - (arg - text) - 1];
			else
				*argptr = NULL;
		}
		else if(text[cmdlen] == 0)
		{
			*argptr = NULL;
		}
		else
		{
			*argptr = text + cmdlen;
		}
	}

	return true;
}

var bot = new Telegram(BOT_TOKEN);
while(true)
{
	var msg = bot.getUpdate();
	if(!(msg instanceof MessageUpdate) || msg.chat != CHAT_ID)
	{
		delete msg;
		continue;
	}

	if(checkCommand(msg.text, "/drink"))
	{
		if(!(msg.senderId in accounts))
		{
			accounts[msg.senderId] = map {
				id: msg.senderId,
				name: strdup!native(msg.sender)[0 .. (sizeof msg.sender) + 1],
				balance: 0
			};
		}

		accounts[msg.senderId].balance -= 1;

		msg.reply("OK, enjoy your drink!");

		saveState();
	}
	else if(checkCommand(msg.text, "/balance"))
	{
		var balance;
		if(msg.senderId in accounts)
			balance = accounts[msg.senderId].balance;
		else
			balance = 0;

		msg.reply("Your balance is: $balance€");
	}
	else if(checkCommand(msg.text, "/blame"))
	{
		var min = false;
		foreach(_, user in accounts)
		{
			if(!min || min.balance >= user.balance)
			{
				min = user;
			}
		}

		if(min)
			msg.reply("It's [${min.name}](tg://user?id=${min.id})s turn to restock the Mate", "markdown");
		else
			msg.reply("No users yet, noone to blame!");
	}
	else if(checkCommand(msg.text, "/pay"))
	{
		msg.reply("Soon™");
	}

	delete msg;
}
